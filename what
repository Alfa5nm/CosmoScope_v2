[1mdiff --git a/server/routes/nasa.ts b/server/routes/nasa.ts[m
[1mindex 45a2445..7a55b49 100644[m
[1m--- a/server/routes/nasa.ts[m
[1m+++ b/server/routes/nasa.ts[m
[36m@@ -1,15 +1,126 @@[m
 import express from 'express'[m
 import fs from 'fs'[m
 import { Agent as UndiciAgent } from 'undici'[m
[31m-import { Readable } from 'stream'[m
[32m+[m[32mimport path from 'path'[m
[32m+[m[32mimport { fileURLToPath } from 'url'[m
[32m+[m[32mimport crypto from 'crypto'[m
 [m
 const router = express.Router()[m
 [m
[32m+[m[32mconst __filename = fileURLToPath(import.meta.url)[m
[32m+[m[32mconst __dirname = path.dirname(__filename)[m
[32m+[m
 // NASA API configuration[m
 const NASA_BASE_URL = 'https://api.nasa.gov'[m
 const NASA_API_KEY = process.env.NASA_API_KEY || 'DEMO_KEY'[m
 [m
[31m-// Proxy NASA API requests[m
[32m+[m[32m// Enhanced caching configuration[m
[32m+[m[32mconst TILE_CACHE_TTL_MS = Number(process.env.TILE_CACHE_TTL_MS ?? 15 * 60 * 1000) // 15 minutes[m
[32m+[m[32mconst TILE_CACHE_MAX_ENTRIES = Number(process.env.TILE_CACHE_MAX_ENTRIES ?? 1000)[m
[32m+[m[32mconst CONFIG_CACHE_TTL_MS = Number(process.env.CONFIG_CACHE_TTL_MS ?? 30 * 60 * 1000) // 30 minutes[m
[32m+[m
[32m+[m[32mtype TileCacheEntry = {[m
[32m+[m[32m  buffer: Buffer[m
[32m+[m[32m  contentType: string[m
[32m+[m[32m  headers: Record<string, string>[m
[32m+[m[32m  storedAt: number[m
[32m+[m[32m  etag: string[m
[32m+[m[32m  lastModified: string[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtype ConfigCacheEntry = {[m
[32m+[m[32m  data: any[m
[32m+[m[32m  etag: string[m
[32m+[m[32m  storedAt: number[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst tileCache = new Map<string, TileCacheEntry>()[m
[32m+[m[32mconst configCache = new Map<string, ConfigCacheEntry>()[m
[32m+[m
[32m+[m[32m// Enhanced ETag generation[m
[32m+[m[32mconst generateETag = (data: Buffer | string): string => {[m
[32m+[m[32m  const hash = crypto.createHash('md5')[m
[32m+[m[32m  hash.update(data)[m
[32m+[m[32m  return `"${hash.digest('hex')}"`[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Enhanced cache entry management[m
[32m+[m[32mconst getCacheEntry = (key: string): TileCacheEntry | null => {[m
[32m+[m[32m  const entry = tileCache.get(key)[m
[32m+[m[32m  if (!entry) {[m
[32m+[m[32m    return null[m
[32m+[m[32m  }[m
[32m+[m[32m  if (Date.now() - entry.storedAt > TILE_CACHE_TTL_MS) {[m
[32m+[m[32m    tileCache.delete(key)[m
[32m+[m[32m    return null[m
[32m+[m[32m  }[m
[32m+[m[32m  return entry[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst storeCacheEntry = (key: string, entry: TileCacheEntry) => {[m
[32m+[m[32m  // Implement LRU eviction[m
[32m+[m[32m  if (tileCache.size >= TILE_CACHE_MAX_ENTRIES) {[m
[32m+[m[32m    const firstKey = tileCache.keys().next().value[m
[32m+[m[32m    if (firstKey) {[m
[32m+[m[32m      tileCache.delete(firstKey)[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  tileCache.set(key, entry)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Enhanced conditional headers with better ETag support[m
[32m+[m[32mconst buildConditionalHeaders = (entry: TileCacheEntry | null) => {[m
[32m+[m[32m  const headers: Record<string, string> = {}[m
[32m+[m[32m  if (entry?.etag) {[m
[32m+[m[32m    headers['If-None-Match'] = entry.etag[m
[32m+[m[32m  }[m
[32m+[m[32m  if (entry?.lastModified) {[m
[32m+[m[32m    headers['If-Modified-Since'] = entry.lastModified[m
[32m+[m[32m  }[m
[32m+[m[32m  return headers[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Config cache management[m
[32m+[m[32mconst getConfigCacheEntry = (key: string): ConfigCacheEntry | null => {[m
[32m+[m[32m  const entry = configCache.get(key)[m
[32m+[m[32m  if (!entry) {[m
[32m+[m[32m    return null[m
[32m+[m[32m  }[m
[32m+[m[32m  if (Date.now() - entry.storedAt > CONFIG_CACHE_TTL_MS) {[m
[32m+[m[32m    configCache.delete(key)[m
[32m+[m[32m    return null[m
[32m+[m[32m  }[m
[32m+[m[32m  return entry[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst storeConfigCacheEntry = (key: string, data: any) => {[m
[32m+[m[32m  const etag = generateETag(JSON.stringify(data))[m
[32m+[m[32m  configCache.set(key, {[m
[32m+[m[32m    data,[m
[32m+[m[32m    etag,[m
[32m+[m[32m    storedAt: Date.now()[m
[32m+[m[32m  })[m
[32m+[m[32m  return etag[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Enhanced tile catalog loading with caching[m
[32m+[m[32mconst loadTileCatalog = (): PlanetTileCatalog => {[m
[32m+[m[32m  const configPath = path.join(__dirname, '../config/tile-sources.json')[m
[32m+[m[32m  if (fs.existsSync(configPath)) {[m
[32m+[m[32m    try {[m
[32m+[m[32m      const data = fs.readFileSync(configPath, 'utf8')[m
[32m+[m[32m      return JSON.parse(data) as PlanetTileCatalog[m
[32m+[m[32m    } catch (error) {[m
[32m+[m[32m      console.error('Error loading tile catalog:', error)[m
[32m+[m[32m      return DEFAULT_TILE_CATALOG[m
[32m+[m[32m    }[m
[32m+[m[32m  } else {[m
[32m+[m[32m    console.warn('Tile catalog not found, using default')[m
[32m+[m[32m    return DEFAULT_TILE_CATALOG[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Proxy NASA API requests with enhanced caching[m
 router.get('/apod', async (req, res) => {[m
   try {[m
     const { date, count, thumbs } = req.query[m
[36m@@ -23,520 +134,305 @@[m [mrouter.get('/apod', async (req, res) => {[m
     const response = await fetch(`${NASA_BASE_URL}/planetary/apod?${params}`)[m
     const data = await response.json()[m
     [m
[31m-    res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('NASA APOD API error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to fetch APOD data' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get NASA image of the day[m
[31m-router.get('/apod/today', async (req, res) => {[m
[31m-  try {[m
[31m-    const response = await fetch(`${NASA_BASE_URL}/planetary/apod?api_key=${NASA_API_KEY}`)[m
[31m-    const data = await response.json()[m
[31m-    [m
[31m-    res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('NASA APOD API error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to fetch today\'s APOD' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get Mars weather data[m
[31m-router.get('/mars-weather', async (req, res) => {[m
[31m-  try {[m
[31m-    const response = await fetch(`${NASA_BASE_URL}/insight_weather/?api_key=${NASA_API_KEY}&feedtype=json&ver=1.0`)[m
[31m-    const data = await response.json()[m
[32m+[m[32m    // Set cache headers[m
[32m+[m[32m    res.set({[m
[32m+[m[32m      'Cache-Control': 'public, max-age=3600', // 1 hour[m
[32m+[m[32m      'ETag': generateETag(JSON.stringify(data))[m
[32m+[m[32m    })[m
     [m
     res.json(data)[m
   } catch (error) {[m
[31m-    console.error('Mars weather API error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to fetch Mars weather data' })[m
[32m+[m[32m    console.error('APOD API error:', error)[m
[32m+[m[32m    res.status(500).json({ error: 'Failed to fetch APOD data' })[m
   }[m
 })[m
 [m
[31m-// Get Earth imagery[m
[31m-router.get('/earth-imagery', async (req, res) => {[m
[32m+[m[32m// Enhanced tile proxy with better caching[m
[32m+[m[32mrouter.get('/tiles/:planet/:layer/:z/:x/:y', async (req, res) => {[m
[32m+[m[32m  const { planet, layer, z, x, y } = req.params[m
[32m+[m[32m  const { date } = req.query[m
[32m+[m[41m  [m
   try {[m
[31m-    const { lat, lon, date, dim } = req.query[m
[32m+[m[32m    const cacheKey = `${planet}-${layer}-${z}-${x}-${y}-${date || 'default'}`[m
[32m+[m[32m    const cachedEntry = getCacheEntry(cacheKey)[m
     [m
[31m-    if (!lat || !lon) {[m
[31m-      return res.status(400).json({ error: 'Latitude and longitude are required' })[m
[32m+[m[32m    // Check if client has cached version[m
[32m+[m[32m    const clientETag = req.headers['if-none-match'][m
[32m+[m[32m    if (cachedEntry && clientETag === cachedEntry.etag) {[m
[32m+[m[32m      return res.status(304).end()[m
     }[m
     [m
[31m-    const params = new URLSearchParams()[m
[31m-    params.append('lat', lat as string)[m
[31m-    params.append('lon', lon as string)[m
[31m-    if (date) params.append('date', date as string)[m
[31m-    if (dim) params.append('dim', dim as string)[m
[31m-    params.append('api_key', NASA_API_KEY)[m
[32m+[m[32m    // Load tile catalog[m
[32m+[m[32m    let tileCatalog: PlanetTileCatalog = loadTileCatalog()[m
     [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/planetary/earth/imagery?${params}`)[m
[31m-    const data = await response.json()[m
[31m-    [m
[31m-    return res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('Earth imagery API error:', error)[m
[31m-    return res.status(500).json({ error: 'Failed to fetch Earth imagery' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get Earth assets[m
[31m-router.get('/earth-assets', async (req, res) => {[m
[31m-  try {[m
[31m-    const { lat, lon, begin, end } = req.query[m
[31m-    [m
[31m-    if (!lat || !lon) {[m
[31m-      return res.status(400).json({ error: 'Latitude and longitude are required' })[m
[32m+[m[32m    const planetConfig = tileCatalog[planet as keyof PlanetTileCatalog][m
[32m+[m[32m    if (!planetConfig) {[m
[32m+[m[32m      return res.status(404).json({ error: `Planet ${planet} not supported` })[m
     }[m
     [m
[31m-    const params = new URLSearchParams()[m
[31m-    params.append('lat', lat as string)[m
[31m-    params.append('lon', lon as string)[m
[31m-    if (begin) params.append('begin', begin as string)[m
[31m-    if (end) params.append('end', end as string)[m
[31m-    params.append('api_key', NASA_API_KEY)[m
[32m+[m[32m    const layerConfig = planetConfig.layers[layer][m
[32m+[m[32m    if (!layerConfig) {[m
[32m+[m[32m      return res.status(404).json({ error: `Layer ${layer} not found for planet ${planet}` })[m
[32m+[m[32m    }[m
     [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/planetary/earth/assets?${params}`)[m
[31m-    const data = await response.json()[m
[32m+[m[32m    // Build tile URL based on layer type[m
[32m+[m[32m    let tileUrl: string[m
[32m+[m[32m    if (layerConfig.type === 'gibs') {[m
[32m+[m[32m      const timeParam = layerConfig.supportsTime && date ? `&time=${date}` : ''[m
[32m+[m[32m      tileUrl = `https://gibs.earthdata.nasa.gov/wmts/1.0.0/${layerConfig.layer}/default/${layerConfig.tileMatrixSet}/${z}/${y}/${x}.${layerConfig.format}${timeParam}`[m
[32m+[m[32m    } else if (layerConfig.type === 'arcgis-image') {[m
[32m+[m[32m      const bbox = getBoundingBox(parseInt(z), parseInt(x), parseInt(y))[m
[32m+[m[32m      tileUrl = `${layerConfig.endpoint}/export?bbox=${bbox.join(',')}&bboxSR=4326&imageSR=4326&size=256,256&format=${layerConfig.format}&f=image`[m
[32m+[m[32m    } else {[m
[32m+[m[32m      return res.status(400).json({ error: `Unsupported layer type: ${layerConfig.type}` })[m
[32m+[m[32m    }[m
     [m
[31m-    return res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('Earth assets API error:', error)[m
[31m-    return res.status(500).json({ error: 'Failed to fetch Earth assets' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get Mars rover photos[m
[31m-router.get('/mars-photos', async (req, res) => {[m
[31m-  try {[m
[31m-    const { rover, sol, camera, page } = req.query[m
[32m+[m[32m    // Fetch tile with conditional headers[m
[32m+[m[32m    const conditionalHeaders = buildConditionalHeaders(cachedEntry)[m
[32m+[m[32m    const response = await fetch(tileUrl, {[m
[32m+[m[32m      headers: {[m
[32m+[m[32m        'User-Agent': 'CosmoScope/1.0',[m
[32m+[m[32m        ...conditionalHeaders[m
[32m+[m[32m      }[m
[32m+[m[32m    })[m
     [m
[31m-    if (!rover) {[m
[31m-      return res.status(400).json({ error: 'Rover name is required' })[m
[32m+[m[32m    // Handle 304 Not Modified[m
[32m+[m[32m    if (response.status === 304 && cachedEntry) {[m
[32m+[m[32m      res.set({[m
[32m+[m[32m        'Content-Type': cachedEntry.contentType,[m
[32m+[m[32m        'ETag': cachedEntry.etag,[m
[32m+[m[32m        'Cache-Control': 'public, max-age=900', // 15 minutes[m
[32m+[m[32m        'Last-Modified': cachedEntry.lastModified[m
[32m+[m[32m      })[m
[32m+[m[32m      return res.send(cachedEntry.buffer)[m
     }[m
     [m
[31m-    const params = new URLSearchParams()[m
[31m-    params.append('rover', rover as string)[m
[31m-    if (sol) params.append('sol', sol as string)[m
[31m-    if (camera) params.append('camera', camera as string)[m
[31m-    if (page) params.append('page', page as string)[m
[31m-    params.append('api_key', NASA_API_KEY)[m
[32m+[m[32m    if (!response.ok) {[m
[32m+[m[32m      return res.status(response.status).json({[m[41m [m
[32m+[m[32m        error: `Failed to fetch tile: ${response.status} ${response.statusText}`,[m
[32m+[m[32m        details: `Tile URL: ${tileUrl}`[m
[32m+[m[32m      })[m
[32m+[m[32m    }[m
     [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/mars-photos/api/v1/rovers/${rover}/photos?${params}`)[m
[31m-    const data = await response.json()[m
[32m+[m[32m    const buffer = Buffer.from(await response.arrayBuffer())[m
[32m+[m[32m    const contentType = response.headers.get('content-type') || 'image/png'[m
[32m+[m[32m    const etag = response.headers.get('etag') || generateETag(buffer)[m
[32m+[m[32m    const lastModified = response.headers.get('last-modified') || new Date().toUTCString()[m
     [m
[31m-    return res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('Mars photos API error:', error)[m
[31m-    return res.status(500).json({ error: 'Failed to fetch Mars photos' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get Mars rover manifest[m
[31m-router.get('/mars-manifest/:rover', async (req, res) => {[m
[31m-  try {[m
[31m-    const { rover } = req.params[m
[32m+[m[32m    // Cache the tile[m
[32m+[m[32m    const cacheEntry: TileCacheEntry = {[m
[32m+[m[32m      buffer,[m
[32m+[m[32m      contentType,[m
[32m+[m[32m      headers: {[m
[32m+[m[32m        'etag': etag,[m
[32m+[m[32m        'last-modified': lastModified[m
[32m+[m[32m      },[m
[32m+[m[32m      storedAt: Date.now(),[m
[32m+[m[32m      etag,[m
[32m+[m[32m      lastModified[m
[32m+[m[32m    }[m
[32m+[m[32m    storeCacheEntry(cacheKey, cacheEntry)[m
     [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/mars-photos/api/v1/manifests/${rover}?api_key=${NASA_API_KEY}`)[m
[31m-    const data = await response.json()[m
[32m+[m[32m    // Set response headers[m
[32m+[m[32m    res.set({[m
[32m+[m[32m      'Content-Type': contentType,[m
[32m+[m[32m      'ETag': etag,[m
[32m+[m[32m      'Cache-Control': 'public, max-age=900', // 15 minutes[m
[32m+[m[32m      'Last-Modified': lastModified[m
[32m+[m[32m    })[m
     [m
[31m-    res.json(data)[m
[32m+[m[32m    res.send(buffer)[m
[32m+[m[32m    return[m
   } catch (error) {[m
[31m-    console.error('Mars manifest API error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to fetch Mars manifest' })[m
[32m+[m[32m    console.error('Tile proxy error:', error)[m
[32m+[m[32m    res.status(500).json({[m[41m [m
[32m+[m[32m      error: 'Internal server error',[m
[32m+[m[32m      details: error instanceof Error ? error.message : 'Unknown error'[m
[32m+[m[32m    })[m
[32m+[m[32m    return[m
   }[m
 })[m
 [m
[31m-// Get NASA image and video library search results[m
[31m-router.get('/search', async (req, res) => {[m
[32m+[m[32m// Enhanced configuration endpoint with caching[m
[32m+[m[32mrouter.get('/config', async (req, res) => {[m
   try {[m
[31m-    const { q, year_start, year_end, media_type, page } = req.query[m
[32m+[m[32m    const cacheKey = 'server-config'[m
[32m+[m[32m    const cachedEntry = getConfigCacheEntry(cacheKey)[m
     [m
[31m-    if (!q) {[m
[31m-      return res.status(400).json({ error: 'Search query is required' })[m
[32m+[m[32m    // Check if client has cached version[m
[32m+[m[32m    const clientETag = req.headers['if-none-match'][m
[32m+[m[32m    if (cachedEntry && clientETag === cachedEntry.etag) {[m
[32m+[m[32m      return res.status(304).end()[m
     }[m
     [m
[31m-    const params = new URLSearchParams()[m
[31m-    params.append('q', q as string)[m
[31m-    if (year_start) params.append('year_start', year_start as string)[m
[31m-    if (year_end) params.append('year_end', year_end as string)[m
[31m-    if (media_type) params.append('media_type', media_type as string)[m
[31m-    if (page) params.append('page', page as string)[m
[31m-    params.append('api_key', NASA_API_KEY)[m
[31m-    [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/search?${params}`)[m
[31m-    const data = await response.json()[m
[31m-    [m
[31m-    return res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('NASA search API error:', error)[m
[31m-    return res.status(500).json({ error: 'Failed to search NASA library' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get NASA image of the day for a specific date[m
[31m-router.get('/apod/:date', async (req, res) => {[m
[31m-  try {[m
[31m-    const { date } = req.params[m
[31m-    [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/planetary/apod?date=${date}&api_key=${NASA_API_KEY}`)[m
[31m-    const data = await response.json()[m
[32m+[m[32m    const config = {[m
[32m+[m[32m      supportedLayers: {[m
[32m+[m[32m        earth: ['blue-marble', 'night-lights', 'thermal', 'elevation'],[m
[32m+[m[32m        moon: ['lroc', 'elevation'],[m
[32m+[m[32m        mars: ['ctx', 'elevation'][m
[32m+[m[32m      },[m
[32m+[m[32m      timeRanges: {[m
[32m+[m[32m        earth: {[m
[32m+[m[32m          start: '2000-01-01',[m
[32m+[m[32m          end: new Date().toISOString().split('T')[0][m
[32m+[m[32m        },[m
[32m+[m[32m        moon: {[m
[32m+[m[32m          start: '2009-01-01',[m
[32m+[m[32m          end: new Date().toISOString().split('T')[0][m
[32m+[m[32m        },[m
[32m+[m[32m        mars: {[m
[32m+[m[32m          start: '2006-01-01',[m
[32m+[m[32m          end: new Date().toISOString().split('T')[0][m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
     [m
[31m-    res.json(data)[m
[31m-  } catch (error) {[m
[31m-    console.error('NASA APOD API error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to fetch APOD for date' })[m
[31m-  }[m
[31m-})[m
[31m-[m
[31m-// Get NASA image of the day for a date range[m
[31m-router.get('/apod/range/:start/:end', async (req, res) => {[m
[31m-  try {[m
[31m-    const { start, end } = req.params[m
[32m+[m[32m    const etag = storeConfigCacheEntry(cacheKey, config)[m
     [m
[31m-    const response = await fetch(`${NASA_BASE_URL}/planetary/apod?start_date=${start}&end_date=${end}&api_key=${NASA_API_KEY}`)[m
[31m-    const data = await response.json()[m
[32m+[m[32m    res.set({[m
[32m+[m[32m      'Cache-Control': 'public, max-age=1800', // 30 minutes[m
[32m+[m[32m      'ETag': etag[m
[32m+[m[32m    })[m
     [m
[31m-    res.json(data)[m
[32m+[m[32m    res.json(config)[m
[32m+[m[32m    return[m
   } catch (error) {[m
[31m-    console.error('NASA APOD range API error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to fetch APOD range' })[m
[32m+[m[32m    console.error('Config endpoint error:', error)[m
[32m+[m[32m    res.status(500).json({ error: 'Failed to fetch configuration' })[m
[32m+[m[32m    return[m
   }[m
 })[m
 [m
[31m-// Proxy NASA WMTS tiles[m
[31m-const GIBS_BASE_URL = 'https://map1.vis.earthdata.nasa.gov/wmts-geo/wmts.cgi'[m
[31m-[m
[31m-type GibsTileConfig = {[m
[31m-  type: 'gibs'[m
[31m-  layer: string[m
[31m-  tileMatrixSet: string[m
[31m-  format: 'jpeg' | 'png'[m
[31m-  supportsTime?: boolean[m
[31m-  defaultTime?: string[m
[31m-}[m
[31m-[m
[31m-type ArcgisImageConfig = {[m
[31m-  type: 'arcgis-image'[m
[31m-  endpoint: string[m
[31m-  format?: 'PNG' | 'PNG8' | 'PNG24' | 'PNG32' | 'JPG'[m
[31m-}[m
[31m-[m
[31m-type IiifTileConfig = {[m
[31m-  type: 'iiif'[m
[31m-  identifier: string[m
[31m-  baseUrl?: string[m
[31m-  format?: 'jpg' | 'jpeg' | 'png'[m
[31m-  size?: number[m
[31m-}[m
[31m-[m
[31m-type TileConfig = GibsTileConfig | ArcgisImageConfig | IiifTileConfig[m
[31m-[m
[31m-const IIIF_BASE_URL = (process.env.IIIF_BASE_URL || 'http://localhost:8182/iiif/2').replace(/\/+$/, '')[m
[31m-const keepAliveAgent = new UndiciAgent({ connect: { keepAlive: true } })[m
[31m-const fetchWithAgent = (url: string) => fetch(url, { dispatcher: keepAliveAgent } as any)[m
[31m-[m
[31m-const trimTrailingSlash = (value: string) => value.replace(/\/+$/, '')[m
[31m-[m
[31m-type IiifInfo = {[m
[31m-  width: number[m
[31m-  height: number[m
[31m-  tiles?: Array<{ width: number; height?: number; scaleFactors: number[] }>[m
[31m-}[m
[31m-[m
[31m-const iiifInfoCache = new Map<string, IiifInfo>()[m
[31m-[m
[31m-const logTile = (message: string) => {[m
[31m-  const timestamp = new Date().toISOString()[m
[31m-  fs.appendFileSync('tile-proxy.log', `[${timestamp}] ${message}[m
[31m-`)[m
[31m-}[m
[31m-[m
[31m-const getIiifInfo = async (config: IiifTileConfig): Promise<IiifInfo> => {[m
[31m-  const base = trimTrailingSlash(config.baseUrl || IIIF_BASE_URL)[m
[31m-  const cacheKey = `${base}/${config.identifier}`[m
[31m-  if (iiifInfoCache.has(cacheKey)) {[m
[31m-    return iiifInfoCache.get(cacheKey)![m
[31m-  }[m
[31m-[m
[31m-  const infoUrl = `${base}/${config.identifier}/info.json`[m
[31m-  const response = await fetch(infoUrl)[m
[31m-[m
[31m-  if (!response.ok) {[m
[31m-    throw new Error(`IIIF info request failed: ${response.status} ${response.statusText}`)[m
[31m-  }[m
[31m-[m
[31m-  const info = (await response.json()) as IiifInfo[m
[31m-[m
[31m-  if (!info.width || !info.height) {[m
[31m-    throw new Error('IIIF info.json missing width/height')[m
[31m-  }[m
[31m-[m
[31m-  iiifInfoCache.set(cacheKey, info)[m
[31m-  return info[m
[32m+[m[32m// Utility function for bounding box calculation[m
[32m+[m[32mconst getBoundingBox = (z: number, x: number, y: number): number[] => {[m
[32m+[m[32m  const n = Math.pow(2, z)[m
[32m+[m[32m  const lonDeg = (x / n) * 360.0 - 180.0[m
[32m+[m[32m  const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n)))[m
[32m+[m[32m  const latDeg = latRad * 180.0 / Math.PI[m
[32m+[m[41m  [m
[32m+[m[32m  const lonDeg2 = ((x + 1) / n) * 360.0 - 180.0[m
[32m+[m[32m  const latRad2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)))[m
[32m+[m[32m  const latDeg2 = latRad2 * 180.0 / Math.PI[m
[32m+[m[41m  [m
[32m+[m[32m  return [lonDeg, latDeg, lonDeg2, latDeg2][m
 }[m
 [m
[31m-const tileSources: Record<string, Record<string, TileConfig>> = {[m
[32m+[m[32m// Default tile catalog fallback[m
[32m+[m[32mconst DEFAULT_TILE_CATALOG: PlanetTileCatalog = {[m
   earth: {[m
[31m-    base: {[m
[31m-      type: 'gibs',[m
[31m-      layer: 'MODIS_Terra_CorrectedReflectance_TrueColor',[m
[31m-      tileMatrixSet: '250m',[m
[31m-      format: 'jpeg',[m
[31m-      supportsTime: true[m
[31m-    },[m
[31m-    thermal: {[m
[31m-      type: 'gibs',[m
[31m-      layer: 'AIRS_L3_Surface_Air_Temperature_Daily_Day',[m
[31m-      tileMatrixSet: '2km',[m
[31m-      format: 'png',[m
[31m-      supportsTime: true,[m
[31m-      defaultTime: '2021-02-01'[m
[31m-    },[m
[31m-    night: {[m
[31m-      type: 'gibs',[m
[31m-      layer: 'VIIRS_CityLights_2012',[m
[31m-      tileMatrixSet: '500m',[m
[31m-      format: 'jpeg',[m
[31m-      defaultTime: '2012-01-01'[m
[31m-    },[m
[31m-    elevation: {[m
[31m-      type: 'gibs',[m
[31m-      layer: 'SRTM_Color_Index',[m
[31m-      tileMatrixSet: '31.25m',[m
[31m-      format: 'png'[m
[32m+[m[32m    defaultLayer: 'base',[m
[32m+[m[32m    layers: {[m
[32m+[m[32m      base: {[m
[32m+[m[32m        type: 'gibs',[m
[32m+[m[32m        layer: 'MODIS_Terra_CorrectedReflectance_TrueColor',[m
[32m+[m[32m        tileMatrixSet: 'EPSG4326_250m',[m
[32m+[m[32m        format: 'jpeg',[m
[32m+[m[32m        supportsTime: true,[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 8[m
[32m+[m[32m      },[m
[32m+[m[32m      thermal: {[m
[32m+[m[32m        type: 'gibs',[m
[32m+[m[32m        layer: 'AIRS_L3_Surface_Air_Temperature_Daily_Day',[m
[32m+[m[32m        tileMatrixSet: 'EPSG4326_2km',[m
[32m+[m[32m        format: 'png',[m
[32m+[m[32m        supportsTime: true,[m
[32m+[m[32m        defaultTime: '2021-02-01',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 5[m
[32m+[m[32m      },[m
[32m+[m[32m      night: {[m
[32m+[m[32m        type: 'gibs',[m
[32m+[m[32m        layer: 'VIIRS_CityLights_2012',[m
[32m+[m[32m        tileMatrixSet: 'EPSG4326_500m',[m
[32m+[m[32m        format: 'jpeg',[m
[32m+[m[32m        defaultTime: '2012-01-01',[m
[32m+[m[32m        supportsTime: false,[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 7[m
[32m+[m[32m      },[m
[32m+[m[32m      elevation: {[m
[32m+[m[32m        type: 'gibs',[m
[32m+[m[32m        layer: 'SRTM_Color_Index',[m
[32m+[m[32m        tileMatrixSet: 'EPSG4326_500m',[m
[32m+[m[32m        format: 'png',[m
[32m+[m[32m        supportsTime: false,[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 11[m
[32m+[m[32m      }[m
     }[m
   },[m
   mars: {[m
[31m-    base: {[m
[31m-      type: 'arcgis-image',[m
[31m-      endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/Mars_Viking_MDIM21_ClrMosaic_global_232m/ImageServer',[m
[31m-      format: 'PNG'[m
[31m-    },[m
[31m-    thermal: {[m
[31m-      type: 'arcgis-image',[m
[31m-      endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/Mars_MGS_MOLA_Colorized_DEM_Global_463m/ImageServer',[m
[31m-      format: 'PNG'[m
[31m-    },[m
[31m-    elevation: {[m
[31m-      type: 'arcgis-image',[m
[31m-      endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/mola128_mola64_merge_90Nto90S_SimpleC_clon0/ImageServer',[m
[31m-      format: 'PNG32'[m
[31m-    },[m
[31m-    night: {[m
[31m-      type: 'arcgis-image',[m
[31m-      endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/Mars_MGS_MOLA_Colorized_DEM_Global_463m/ImageServer',[m
[31m-      format: 'PNG'[m
[32m+[m[32m    defaultLayer: 'base',[m
[32m+[m[32m    layers: {[m
[32m+[m[32m      base: {[m
[32m+[m[32m        type: 'arcgis-image',[m
[32m+[m[32m        endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/Mars_Viking_MDIM21_ClrMosaic_global_232m/ImageServer',[m
[32m+[m[32m        format: 'PNG',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 9[m
[32m+[m[32m      },[m
[32m+[m[32m      thermal: {[m
[32m+[m[32m        type: 'arcgis-image',[m
[32m+[m[32m        endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/Mars_MGS_MOLA_Colorized_DEM_Global_463m/ImageServer',[m
[32m+[m[32m        format: 'PNG',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 8[m
[32m+[m[32m      },[m
[32m+[m[32m      elevation: {[m
[32m+[m[32m        type: 'arcgis-image',[m
[32m+[m[32m        endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/mola128_mola64_merge_90Nto90S_SimpleC_clon0/ImageServer',[m
[32m+[m[32m        format: 'PNG32',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 9[m
[32m+[m[32m      },[m
[32m+[m[32m      night: {[m
[32m+[m[32m        type: 'arcgis-image',[m
[32m+[m[32m        endpoint: 'https://trek.nasa.gov/mars/trekarcgis/rest/services/Mars_MGS_MOLA_Colorized_DEM_Global_463m/ImageServer',[m
[32m+[m[32m        format: 'PNG',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 8[m
[32m+[m[32m      }[m
     }[m
   },[m
   moon: {[m
[31m-    base: {[m
[31m-      type: 'arcgis-image',[m
[31m-      endpoint: 'https://trek.nasa.gov/moon/trekarcgis/rest/services/LRO_WAC_Mosaic_Global_303ppd_v02/ImageServer',[m
[31m-      format: 'PNG'[m
[31m-    },[m
[31m-    elevation: {[m
[31m-      type: 'arcgis-image',[m
[31m-      endpoint: 'https://trek.nasa.gov/moon/trekarcgis/rest/services/LRO_LOLA_DEM_Global_256ppd_v06/ImageServer',[m
[31m-      format: 'PNG32'[m
[32m+[m[32m    defaultLayer: 'base',[m
[32m+[m[32m    layers: {[m
[32m+[m[32m      base: {[m
[32m+[m[32m        type: 'arcgis-image',[m
[32m+[m[32m        endpoint: 'https://trek.nasa.gov/moon/trekarcgis/rest/services/LRO_WAC_Mosaic_Global_303ppd_v02/ImageServer',[m
[32m+[m[32m        format: 'PNG',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 10[m
[32m+[m[32m      },[m
[32m+[m[32m      elevation: {[m
[32m+[m[32m        type: 'arcgis-image',[m
[32m+[m[32m        endpoint: 'https://trek.nasa.gov/moon/trekarcgis/rest/services/LRO_LOLA_DEM_Global_256ppd_v06/ImageServer',[m
[32m+[m[32m        format: 'PNG32',[m
[32m+[m[32m        minZoom: 0,[m
[32m+[m[32m        maxZoom: 10[m
[32m+[m[32m      }[m
     }[m
   }[m
 }[m
 [m
[31m-type PlanetKey = keyof typeof tileSources[m
[31m-const defaultLayers: Record<string, string> = {[m
[31m-  earth: 'base',[m
[31m-  mars: 'base',[m
[31m-  moon: 'base'[m
[31m-}[m
[31m-[m
[31m-const tileToBBox4326 = (z: number, x: number, y: number) => {[m
[31m-  const n = Math.pow(2, z)[m
[31m-  const lonMin = (x / n) * 360 - 180[m
[31m-  const lonMax = ((x + 1) / n) * 360 - 180[m
[31m-  const latRadMax = Math.atan(Math.sinh(Math.PI * (1 - (2 * y) / n)))[m
[31m-  const latRadMin = Math.atan(Math.sinh(Math.PI * (1 - (2 * (y + 1)) / n)))[m
[31m-  const latMax = (latRadMax * 180) / Math.PI[m
[31m-  const latMin = (latRadMin * 180) / Math.PI[m
[31m-  return [lonMin, latMin, lonMax, latMax][m
[31m-}[m
[31m-[m
[31m-const xyzToIiifRegion = (info: IiifInfo, z: number, x: number, y: number) => {[m
[31m-  const tilesPerAxis = Math.pow(2, z)[m
[31m-  const regionWidth = Math.ceil(info.width / tilesPerAxis)[m
[31m-  const regionHeight = Math.ceil(info.height / tilesPerAxis)[m
[31m-  const minX = Math.min(x * regionWidth, info.width)[m
[31m-  const minY = Math.min(y * regionHeight, info.height)[m
[31m-  const width = Math.max(Math.min(regionWidth, info.width - minX), 0)[m
[31m-  const height = Math.max(Math.min(regionHeight, info.height - minY), 0)[m
[31m-[m
[31m-  return {[m
[31m-    region: `${minX},${minY},${width},${height}`,[m
[31m-    width,[m
[31m-    height[m
[31m-  }[m
[31m-}[m
[31m-[m
[31m-router.get('/tiles/:planet/:layer/:z/:x/:y', async (req: express.Request, res: express.Response): Promise<void> => {[m
[31m-  try {[m
[31m-    const { planet, layer, z, x, y } = req.params[m
[31m-    const { date } = req.query[m
[31m-[m
[31m-    const querySuffix = typeof date === 'string' && date.trim().length > 0 ? `?date=${date}` : ''[m
[31m-    console.log(`Proxying tile request: ${planet}/${layer}/${z}/${x}/${y}${querySuffix}`)[m
[31m-    logTile(`Proxying ${planet}/${layer}/${z}/${x}/${y}${querySuffix}`)[m
[31m-[m
[31m-    const planetKey = planet as PlanetKey[m
[31m-    const planetSources = tileSources[planetKey][m
[31m-    if (!planetSources) {[m
[31m-      res.status(404).json({ error: `Planet ${planet} not supported` })[m
[31m-      return[m
[31m-    }[m
[31m-[m
[31m-    const fallbackLayer = defaultLayers[planetKey] ?? Object.keys(planetSources)[0][m
[31m-    const hasRequestedLayer = typeof layer === 'string' && Object.prototype.hasOwnProperty.call(planetSources, layer)[m
[31m-    const targetLayerKey = (hasRequestedLayer ? layer : fallbackLayer) as keyof typeof planetSources | undefined[m
[31m-[m
[31m-    if (!targetLayerKey) {[m
[31m-      res.status(404).json({ error: `No tile layers configured for planet ${planet}` })[m
[31m-      return[m
[31m-    }[m
[31m-[m
[31m-    const layerConfig = planetSources[targetLayerKey][m
[31m-[m
[31m-    if (!layerConfig) {[m
[31m-      res.status(404).json({ error: `Layer ${layer} not supported for planet ${planet}` })[m
[31m-      return[m
[31m-    }[m
[31m-[m
[31m-    const zNum = Number(z)[m
[31m-    const xNum = Number(x)[m
[31m-    const yNum = Number(y)[m
[31m-[m
[31m-    if (![zNum, xNum, yNum].every(Number.isFinite)) {[m
[31m-      res.status(400).json({ error: 'Invalid tile coordinates supplied' })[m
[31m-      return[m
[31m-    }[m
[31m-[m
[31m-    let upstreamResponse: Response[m
[31m-[m
[31m-    if (layerConfig.type === 'gibs') {[m
[31m-      const params = new URLSearchParams({[m
[31m-        SERVICE: 'WMTS',[m
[31m-        REQUEST: 'GetTile',[m
[31m-        VERSION: '1.0.0',[m
[31m-        LAYER: layerConfig.layer,[m
[31m-        STYLE: 'default',[m
[31m-        TILEMATRIXSET: layerConfig.tileMatrixSet,[m
[31m-        TILEMATRIX: String(z),[m
[31m-        TILEROW: String(y),[m
[31m-        TILECOL: String(x),[m
[31m-        FORMAT: `image/${layerConfig.format}`[m
[31m-      })[m
[31m-[m
[31m-      const isoDate = typeof date === 'string' ? date.trim() : ''[m
[31m-      if (layerConfig.supportsTime) {[m
[31m-        if (isoDate) {[m
[31m-          params.append('TIME', isoDate)[m
[31m-        } else if (layerConfig.defaultTime) {[m
[31m-          params.append('TIME', layerConfig.defaultTime)[m
[31m-        }[m
[31m-      }[m
[31m-[m
[31m-      const gibsUrl = `${GIBS_BASE_URL}?${params.toString()}`[m
[31m-      logTile(`Fetching GIBS tile: ${gibsUrl}`)[m
[31m-      upstreamResponse = await fetchWithAgent(gibsUrl)[m
[31m-    } else if (layerConfig.type === 'arcgis-image') {[m
[31m-      const bbox = tileToBBox4326(zNum, xNum, yNum)[m
[31m-      const params = new URLSearchParams({[m
[31m-        bbox: bbox.join(','),[m
[31m-        bboxSR: '4326',[m
[31m-        imageSR: '4326',[m
[31m-        size: '256,256',[m
[31m-        format: layerConfig.format || 'PNG32',[m
[31m-        transparent: 'true',[m
[31m-        f: 'image'[m
[31m-      })[m
[31m-[m
[31m-      const arcgisUrl = `${trimTrailingSlash(layerConfig.endpoint)}/exportImage?${params.toString()}`[m
[31m-      logTile(`Fetching ArcGIS tile: ${arcgisUrl}`)[m
[31m-      upstreamResponse = await fetchWithAgent(arcgisUrl)[m
[31m-    } else {[m
[31m-      const info = await getIiifInfo(layerConfig)[m
[31m-      const { region, width, height } = xyzToIiifRegion(info, zNum, xNum, yNum)[m
[31m-[m
[31m-      if (width === 0 || height === 0) {[m
[31m-        res.status(404).json({ error: 'Tile out of bounds' })[m
[31m-      return[m
[31m-      }[m
[31m-[m
[31m-      const size = layerConfig.size ?? 256[m
[31m-      const format = layerConfig.format ?? 'jpg'[m
[31m-      const iiifBase = trimTrailingSlash(layerConfig.baseUrl || IIIF_BASE_URL)[m
[31m-      const iiifUrl = `${iiifBase}/${layerConfig.identifier}/${region}/${size},/0/default.${format}`[m
[31m-[m
[31m-      logTile(`Fetching IIIF tile: ${iiifUrl}`)[m
[31m-      upstreamResponse = await fetchWithAgent(iiifUrl)[m
[31m-    }[m
[31m-[m
[31m-    logTile(`Upstream status: ${upstreamResponse.status}`)[m
[31m-    if (!upstreamResponse.ok) {[m
[31m-      let upstreamBody = ''[m
[31m-      try {[m
[31m-        upstreamBody = await upstreamResponse.text()[m
[31m-      } catch (readError) {[m
[31m-        console.error('Failed to read upstream error body:', readError)[m
[31m-      }[m
[31m-[m
[31m-      const errorMsg = `Failed to fetch tile: ${upstreamResponse.status} ${upstreamResponse.statusText} - ${upstreamBody.slice(0, 200)}`[m
[31m-      console.error(errorMsg)[m
[31m-      logTile(errorMsg)[m
[31m-      res.status(upstreamResponse.status).json({ error: 'Failed to fetch tile' })[m
[31m-      return[m
[31m-    }[m
[31m-[m
[31m-    const contentType =[m
[31m-      upstreamResponse.headers.get('content-type') ||[m
[31m-      (layerConfig.type === 'gibs' && layerConfig.format === 'jpeg'[m
[31m-        ? 'image/jpeg'[m
[31m-        : layerConfig.type === 'iiif'[m
[31m-          ? `image/${layerConfig.format === 'png' ? 'png' : 'jpeg'}`[m
[31m-          : 'image/png')[m
[31m-[m
[31m-    res.set({[m
[31m-      'Content-Type': contentType,[m
[31m-      'Cache-Control': 'public, max-age=3600',[m
[31m-      'Access-Control-Allow-Origin': '*'[m
[31m-    })[m
[31m-[m
[31m-    if (upstreamResponse.body) {[m
[31m-      try {[m
[31m-        Readable.fromWeb(upstreamResponse.body as any).pipe(res)[m
[31m-        return[m
[31m-      } catch (streamError) {[m
[31m-        console.error('Streaming error:', streamError)[m
[31m-        logTile(`Streaming error: ${streamError instanceof Error ? streamError.message : String(streamError)}`)[m
[32m+[m[32mtype PlanetTileCatalog = {[m
[32m+[m[32m  [planet: string]: {[m
[32m+[m[32m    defaultLayer: string[m
[32m+[m[32m    layers: {[m
[32m+[m[32m      [layer: string]: {[m
[32m+[m[32m        type: 'gibs' | 'arcgis-image' | 'iiif'[m
[32m+[m[32m        layer?: string[m
[32m+[m[32m        endpoint?: string[m
[32m+[m[32m        tileMatrixSet?: string[m
[32m+[m[32m        format: string[m
[32m+[m[32m        supportsTime?: boolean[m
[32m+[m[32m        defaultTime?: string[m
[32m+[m[32m        minZoom: number[m
[32m+[m[32m        maxZoom: number[m
       }[m
     }[m
[31m-[m
[31m-    res.status(500).json({ error: 'No response body from upstream tile provider' })[m
[31m-    return[m
[31m-  } catch (error) {[m
[31m-    console.error('Tile proxy error:', error)[m
[31m-    res.status(500).json({ error: 'Failed to proxy tile' })[m
[31m-    return[m
[31m-    return[m
   }[m
[31m-})[m
[31m-[m
[31m-[m
[31m-export default router[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[32m+[m[32m}[m
 [m
[32m+[m[32mexport default router[m
\ No newline at end of file[m
